const canvas=document.querySelector("#c");if(!navigator.gpu)throw new Error("WebGPU not supported");
const rect=(x0,y0,x1,y1,r,g,b)=>[x0,y0,r,g,b,x1,y0,r,g,b,x1,y1,r,g,b,x0,y0,r,g,b,x1,y1,r,g,b,x0,y1,r,g,b];
const tri=(ax,ay,bx,by,cx,cy,r,g,b)=>[ax,ay,r,g,b,bx,by,r,g,b,cx,cy,r,g,b];
const circle=(cx,cy,rad,segs,r,g,b)=>{const o=[];for(let i=0;i<segs;i++){const a1=Math.PI*2*i/segs,a2=Math.PI*2*(i+1)/segs;
o.push(...tri(cx,cy,cx+Math.cos(a1)*rad,cy+Math.sin(a1)*rad,cx+Math.cos(a2)*rad,cy+Math.sin(a2)*rad,r,g,b))}return o};

(async()=>{
const adapter=await navigator.gpu.requestAdapter();if(!adapter)throw new Error("No adapter");
const device=await adapter.requestDevice();
const ctx=canvas.getContext("webgpu");
const fmt=navigator.gpu.getPreferredCanvasFormat();
ctx.configure({device,format:fmt,alphaMode:"opaque"});

const shader=`
struct O{ @builtin(position) p:vec4f,@location(0)c:vec3f }
@vertex fn v(@location(0)p:vec2f,@location(1)c:vec3f)->O{var o:O;o.p=vec4f(p.x,-p.y,0,1);o.c=c;return o;}
@fragment fn f(@location(0)c:vec3f)->@location(0)vec4f{return vec4f(c,1);}
`;

const pipe=device.createRenderPipeline({
layout:"auto",
vertex:{module:device.createShaderModule({code:shader}),entryPoint:"v",
buffers:[{arrayStride:20,attributes:[
{shaderLocation:0,offset:0,format:"float32x2"},
{shaderLocation:1,offset:8,format:"float32x3"}]}]},
fragment:{module:device.createShaderModule({code:shader}),entryPoint:"f",targets:[{format:fmt}]},
primitive:{topology:"triangle-list"}
});

const v=[];
v.push(...rect(-1,-1,1,.15,.02,.2,.35));
v.push(...rect(-1,.15,1,1,.08,.45,.2));

const sx=-.65,sy=-.65;
v.push(...circle(sx,sy,.12,24,1,.85,.15));
for(let i=0;i<8;i++){
const a=Math.PI*2*i/8;
v.push(...tri(sx+Math.cos(a)*.14,sy+Math.sin(a)*.14,
              sx+Math.cos(a+.18)*.14,sy+Math.sin(a+.18)*.14,
              sx+Math.cos(a+.09)*.23,sy+Math.sin(a+.09)*.23,
              1,.75,.1))
}

v.push(...rect(-.15,.15,.35,.55,.55,.33,.18));
v.push(...tri(-.22,.15,.42,.15,.1,-.1,.35,.16,.1));
v.push(...rect(.02,.3,.12,.55,.2,.12,.08));
v.push(...rect(.2,.28,.32,.4,.65,.85,1));

const tree=x=>{
v.push(...rect(x-.03,.35,x+.03,.6,.3,.18,.1));
v.push(...tri(x-.14,.4,x+.14,.4,x,.1,.05,.3,.12));
v.push(...tri(x-.12,.28,x+.12,.28,x,.02,.06,.35,.14));
};
tree(-.6); tree(.7);

const buf=device.createBuffer({size:v.length*4,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});
device.queue.writeBuffer(buf,0,new Float32Array(v));

const enc=device.createCommandEncoder();
const pass=enc.beginRenderPass({colorAttachments:[{
view:ctx.getCurrentTexture().createView(),
clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});
pass.setPipeline(pipe);pass.setVertexBuffer(0,buf);pass.draw(v.length/5);pass.end();
device.queue.submit([enc.finish()]);
})();
